import Foundation
import plate

func buildLibrary(targetDirectory: String, buildType: BuildType, local: Bool) async throws {
    let buildString = buildType.directoryString()

    guard let libraryName = await getPackageName(from: targetDirectory) else {
        throw NSError(domain: "sbm.lib", code: 1, userInfo: [NSLocalizedDescriptionKey: "Could not determine package name."])
    }

    let args = [
        "build",
        "-c",
        "\(buildString)",
        "-Xswiftc",
        "-enable-library-evolution",
        "-Xswiftc",
        "-emit-module-interface-path",
        "-Xswiftc",
        ".build/\(buildString)/Modules/\(libraryName).swiftinterface",
        "-Xswiftc",
        "-emit-library",
        "-Xswiftc",
        "-emit-module",
    ]

    print("Building library...")
    guard await runShellCommand("swift", args, in: targetDirectory) else {
        throw NSError(domain: "sbm.lib", code: 2, userInfo: [NSLocalizedDescriptionKey: "Build failed"])
    }

    let modulePath = URL(fileURLWithPath: targetDirectory).appendingPathComponent(".build/\(buildString)/Modules/")
    let libRoot = URL(fileURLWithPath: targetDirectory).appendingPathComponent(".build/\(buildString)/")

    let baseModulesPath = URL(fileURLWithPath: setupSBMLibraryDirectory()).appendingPathComponent(libraryName)
    let fm = FileManager.default
    try? fm.createDirectory(atPath: baseModulesPath.path, withIntermediateDirectories: true)

    do {
        let moduleFiles = try fm.contentsOfDirectory(atPath: modulePath.path)
            .filter { $0.hasSuffix(".swiftmodule") || $0.hasSuffix(".swiftdoc") || $0.hasSuffix(".abi.json") || $0.hasSuffix(".swiftsourceinfo") || $0.hasSuffix(".swiftinterface") }

        let libraryFiles = try fm.contentsOfDirectory(atPath: libRoot.path)
            .filter { $0.hasSuffix(".dylib") || $0.hasSuffix(".a") }

        guard !moduleFiles.isEmpty || !libraryFiles.isEmpty else {
            throw NSError(domain: "sbm.lib", code: 3, userInfo: [NSLocalizedDescriptionKey: "No module or library files found"])
        }

        if !local {
            for file in moduleFiles {
                let src = modulePath.appendingPathComponent(file)
                let dst = baseModulesPath.appendingPathComponent(file)
                try? fm.removeItem(at: dst)
                try fm.copyItem(at: src, to: dst)
                print("Module file moved: \(file)".ansi(.brightBlack, .bold))
            }
            for file in libraryFiles {
                let src = libRoot.appendingPathComponent(file)
                let dst = baseModulesPath.appendingPathComponent(file)
                try? fm.removeItem(at: dst)
                try fm.copyItem(at: src, to: dst)
                print("Library file moved: \(file)".ansi(.brightBlack, .bold))
            }

            let metadataPath = baseModulesPath.appendingPathComponent("library.metadata")
            let metadataContent = "ProjectRootPath=\(targetDirectory)\n"
            try metadataContent.write(to: metadataPath, atomically: true, encoding: .utf8)
            print("Metadata file created at ".ansi(.brightBlack) + "\(metadataPath.path)".ansi(.brightBlack, .bold))
        } else {
            print("Build retained locally".ansi(.brightBlack))
        }
    } catch {
        throw NSError(domain: "sbm.lib", code: 4, userInfo: [NSLocalizedDescriptionKey: "Failed to stage/copy artifacts: \(error)"])
    }

    print("\nLibrary build complete!".ansi(.green))
    if local {
        print("\n'\(libraryName)' is now locally available.".ansi(.green))
    } else {
        print("\nModules are now in sbm-bin/modules/\(libraryName)/.".ansi(.green))
    }
}
